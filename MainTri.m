function MainTri
% MAINTRI Command center of the FreeHyTE - Structural HTD module with
% non-regular meshes of triangular elements.
%
% MAINTRI is called upon exiting the data input (GUI) phase of the module.
% It is used to call all functions required for the solution of the 
% structural problem and centralize all data they provide. 
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Structural HTD User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHWWkyb2xmTGhLa1k
% 4. Silva V - Elementos finitos híbridos-Trefftz de deslocamento para 
% problemas de elasticidade plana, MSc Thesis, Universidade Nova de Lisboa,
% 2016 (in Portuguese).

close all;

%% Pre-processing

% Launch pre-processing routine
% * NGP is the number of Gauss points for the line integration;
% * Nodes is a (NNODE x 2) matrix, where NNODE is the number of nodes in 
% mesh. It stores the coordinates of each node;
% * Edges, Loops and BConds are data structures storing information
% on the edges, finite elements (loops) and boundary conditions,
% respectively. They are documented in Section 5.3 of reference [2];
% * NoDiv^2 is the number of points for plotting the colormaps of the
% solution. 
[NGP, Nodes, Edges, Loops, BConds, NoDiv] = InputProcTri;

% ASSIGNPARTS maps the finite element solving system and assigns entries
% and dimensions to elements and sides. The information is used by the
% functions that generate the blocks of the solving system to insert them
% at the right positions.
% * Dim is the total dimension of the finite element solving system;
% * the mapping of the solving system is covered in Section 6.2 of
% reference [2].
[Edges,Loops,Dim] = AssignParts(Edges, Loops, BConds);

% Initialization of the matrix of coefficients and the free vector
% * LHS is the matrix of coefficients of the solving system;
% * RHS is the free vector of the solving system.
LHS = zeros(Dim);
RHS = zeros(Dim,1);

% Initialization of Gauss-Legendre weights & abscissas (on a -1:1
% interval). gauleg is a external routine, written by Greg von Winckel.
[abscissa,weight] = gauleg(NGP, -1, 1);


%% Generation of the solving system
% Generation & allocation of the blocks in the matrix of coefficients.
% General mapping of the matrix of coefficients of hybrid-Trefftz elements:
%   _______________________________________________              _______
%  |       |       |       |       |       |       |  <------>  |       |
%  |  K11  |  K12  |  K13  |  K14  |   0   |   B1  |            |   T1  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K21  |  K22  |  K23  |  K24  |   0   |   B2  |            |   T2  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K31  |  K32  |  K33  |  K34  |   0   |   B3  |            |   T3  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |  K41  |  K42  |  K43  |  K44  |   0   |   B4  |            |   T4  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |   0   |   0   |   0   |   0   |   0   |   B5  |            |   T5  |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%  |       |       |       |       |       |       |            |       |
%  |   B1  |   B2  |   B3  |   B4  |   B5  |   0   |            |  -U   |
%  |_______|_______|_______|_______|_______|_______|            |_______|
%
%
% The stiffness and boundary matrices of hybrid-Trefftz elements have 
% entries that correspond to the parts of the bases generated by odd and 
% even, harmonic and biharmonic potentials:
% * 1 - basis generated by odd harmonic potentials;
% * 2 - basis generated by even harmonic potentials;
% * 3 - basis generated by odd biharmonic potentials;
% * 4 - basis generated by even biharmonic potentials;
% * 5 - rigid body modes (no stiffness).
%
% The following functions generate the coefficients blocks for each finite
% element and essential boundary and insert them at the right place,
% according to the mapping information generated in ASSIGNPARTS. Since the
% system is symmetric, Kij blocks are calculated and Kji blocks are
% inserted directly.
%
% The explicit expressions of the stiffness and boundary matrices are given
% in Chapter 3 of reference [4].
LHS = K11(Edges, Loops, LHS, abscissa, weight);
LHS = K12(Edges, Loops, LHS, abscissa, weight);
LHS = K13(Edges, Loops, LHS, abscissa, weight);
LHS = K14(Edges, Loops, LHS, abscissa, weight);
LHS = K22(Edges, Loops, LHS, abscissa, weight);
LHS = K23(Edges, Loops, LHS, abscissa, weight);
LHS = K24(Edges, Loops, LHS, abscissa, weight);
LHS = K33(Edges, Loops, LHS, abscissa, weight);
LHS = K34(Edges, Loops, LHS, abscissa, weight);
LHS = K44(Edges, Loops, LHS, abscissa, weight);
LHS = B1(Edges, Loops, LHS, abscissa, weight);
LHS = B2(Edges, Loops, LHS, abscissa, weight);
LHS = B3(Edges, Loops, LHS, abscissa, weight);
LHS = B4(Edges, Loops, LHS, abscissa, weight);
LHS = B5(Edges, Loops, LHS, abscissa, weight);


% Generation & allocation of the blocks in the free vector.
% The general mapping of the free vector is consistent to that of the
% coefficient matrix (above). The terms corresponding to the stiffness
% matrices (Ti) represent generalized tractions applied to the Neumann
% boundaries of the mesh. The terms corresponding to the boundary matrices
% (U) represent generalized displacements applied to the Dirichlet
% boundaries of the mesh, or are null if the boundary is interior.
%
% The following functions generate the free vectors for each finite
% element and essential boundary and insert them at the right place,
% according to the mapping information generated in ASSIGNPARTS. 
%
% The explicit expressions of the free vectors are given in Chapter 3 of 
% reference [4].
RHS = T1(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T2(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T3(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T4(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = T5(Edges, Loops, BConds, RHS, abscissa, weight);
RHS = U(Edges, BConds, RHS, abscissa, weight);

%% Pre-conditioning and solution of the solving system
%
% Pre-conditioning and storage of the solving system
%
% * the solving system is pre-conditioned using a scaling procedure aimed
% at reducing its diagonal elements to unity while preserving the symmetry
% of the original system;
% * the scaling procedure is described in Section 6.2 of reference [2];
% * if the system results too large for the storage memory available to
% Matlab, it is stored in a sparse form.
%
% Generating the scaling matrix, Sc. Sc is a diagonal matrix, whose terms 
% are defined as the inverse of the square roots of the diagonal terms of 
% the coefficient matrix. 
Sc = sqrt(diag(LHS)).^-1;

% If the diagonal term is null, the respective line and column remain 
% unscaled.
Sc(isinf(Sc)) = 1;
Sc = diag(Sc);

% * SparseQ is a flag indicating if the system is stored in sparse or in
% full;
% * ScLHS and ScRHS are the scaled versions of the matrix of coefficients
% and the free vector.
SparseQ = 0;
try % checking if out of memory...
    ScLHS = Sc' * LHS * Sc;
catch % ... and going sparse if it is
    Sc = sparse(Sc);
    LHS = sparse(LHS);
    ScLHS = Sc' * LHS * Sc;
    SparseQ = 1;
end
ScRHS = Sc' * RHS;

% Solution of the solving system
%
% The default Matlab solver (mldivide) is used for the solution of well-
% conditioned solving systems. A truncated singular value decomposition 
% technique is used to find the solution of ill-conditioned systems.
% To detect ill-conditioned systems, an estimate of the condition number of 
% the matrix of coefficients is calculated. If the reciprocal of the 
% condition number is smaller than the precision of the machine, the system 
% is considered ill-conditioned and its solution is based on the 
% computation of the Moore-Penrose pseudoinverse of the matrix. Matlab’s 
% default tolerance for eliminating (truncating) small singular values is 
% used.
if ~SparseQ % if not sparse
    % Computing the estimate of the reciprocal of the condition number
    CndNo=rcond(ScLHS);
    if (CndNo<eps) % checking if it's inferior to the machine precision
        warning('local:NumericalChk',...
            'System condition number is %0.5g. Results might be inaccurate.\n',...
            CndNo);
        % Moore-Penrose pseudoinverse-based solution procedure
        ScX = pinv(ScLHS)*ScRHS;
    else
        % Default solution procedure
        ScX = ScLHS\ScRHS;
    end
else % if sparse
    % Default solution procedure
    ScX = ScLHS\ScRHS;
end

% Reverting the scaling of the solution
X = Sc * ScX;

%% Post-processing
%
% Construct the displacement and stress fields and plot the solution.
% COMPUTEFIELDSREG returns the values of the fields in a NoDiv x NoDiv grid
% in each element, but these values are not used, by default. 
[~, ~, ~, ~, ~] = ComputeFieldsTri(NoDiv, Nodes, Edges, Loops,X);

% House cleaning: restoring warnings
warning('on','MATLAB:DELETE:FileNotFound');
warning('on','MATLAB:load:variableNotFound');

end
